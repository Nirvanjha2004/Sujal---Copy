import sharp from 'sharp';

/**
 * Image sizes generated by the service
 */
export interface ImageSizes {
  thumbnail: Buffer;  // 300px width
  medium: Buffer;     // 800px width
  large: Buffer;      // 1600px width
  original: Buffer;   // Optimized original
}

/**
 * Image sizes with both JPEG and WebP formats
 */
export interface ImageSizesWithWebP {
  jpeg: ImageSizes;
  webp: ImageSizes;
}

/**
 * Processing options for images
 */
export interface ProcessingOptions {
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
  generateSizes?: boolean;
}

/**
 * Image validation result
 */
export interface ValidationResult {
  isValid: boolean;
  error?: string;
  width?: number;
  height?: number;
  format?: string;
  size?: number;
}

/**
 * Image Processing Service
 * Handles image optimization, resizing, and validation using Sharp
 */
export class ImageProcessingService {
  // Size configurations
  private readonly THUMBNAIL_WIDTH = 300;
  private readonly MEDIUM_WIDTH = 800;
  private readonly LARGE_WIDTH = 1600;

  // Quality settings
  private readonly DEFAULT_QUALITY = 85;
  private readonly THUMBNAIL_QUALITY = 80;
  private readonly WEBP_QUALITY = 85; // Optimal WebP quality for size/quality balance

  // File size limits
  private readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  private readonly MIN_WIDTH = 100;
  private readonly MIN_HEIGHT = 100;

  // Allowed formats
  private readonly ALLOWED_FORMATS = ['jpeg', 'jpg', 'png', 'webp'];

  /**
   * Process an image and generate all size variants
   */
  async processImage(
    buffer: Buffer,
    options: ProcessingOptions = {}
  ): Promise<ImageSizes> {
    try {
      const {
        quality = this.DEFAULT_QUALITY,
        format = 'jpeg',
        generateSizes = true,
      } = options;

      // Validate image first
      const validation = await this.validateImage(buffer);
      if (!validation.isValid) {
        throw new Error(validation.error || 'Invalid image');
      }

      // Optimize original
      const original = await this.optimizeImage(buffer, quality, format);

      if (!generateSizes) {
        return {
          original,
          thumbnail: original,
          medium: original,
          large: original,
        };
      }

      // Generate all sizes in parallel
      const [thumbnail, medium, large] = await Promise.all([
        this.generateThumbnail(buffer, this.THUMBNAIL_WIDTH, this.THUMBNAIL_QUALITY, format),
        this.resizeImage(buffer, this.MEDIUM_WIDTH, quality, format),
        this.resizeImage(buffer, this.LARGE_WIDTH, quality, format),
      ]);

      return {
        thumbnail,
        medium,
        large,
        original,
      };
    } catch (error) {
      console.error('Image processing error:', error);
      throw new Error(`Failed to process image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Optimize an image without resizing
   */
  async optimizeImage(
    buffer: Buffer,
    quality: number = this.DEFAULT_QUALITY,
    format: 'jpeg' | 'png' | 'webp' = 'jpeg'
  ): Promise<Buffer> {
    try {
      let pipeline = sharp(buffer);

      // Apply format-specific optimization
      switch (format) {
        case 'jpeg':
          pipeline = pipeline.jpeg({
            quality,
            progressive: true,
            mozjpeg: true,
          });
          break;
        case 'png':
          pipeline = pipeline.png({
            quality,
            compressionLevel: 9,
            progressive: true,
          });
          break;
        case 'webp':
          pipeline = pipeline.webp({
            quality,
            effort: 6,
          });
          break;
      }

      return await pipeline.toBuffer();
    } catch (error) {
      console.error('Image optimization error:', error);
      throw new Error(`Failed to optimize image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Generate a thumbnail
   */
  async generateThumbnail(
    buffer: Buffer,
    width: number = this.THUMBNAIL_WIDTH,
    quality: number = this.THUMBNAIL_QUALITY,
    format: 'jpeg' | 'png' | 'webp' = 'jpeg'
  ): Promise<Buffer> {
    try {
      return await sharp(buffer)
        .resize(width, null, {
          fit: 'inside',
          withoutEnlargement: true,
        })
        .jpeg({ quality, progressive: true })
        .toBuffer();
    } catch (error) {
      console.error('Thumbnail generation error:', error);
      throw new Error(`Failed to generate thumbnail: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Resize an image to a specific width
   */
  private async resizeImage(
    buffer: Buffer,
    width: number,
    quality: number,
    format: 'jpeg' | 'png' | 'webp'
  ): Promise<Buffer> {
    try {
      let pipeline = sharp(buffer).resize(width, null, {
        fit: 'inside',
        withoutEnlargement: true,
      });

      switch (format) {
        case 'jpeg':
          pipeline = pipeline.jpeg({ quality, progressive: true });
          break;
        case 'png':
          pipeline = pipeline.png({ quality, compressionLevel: 9 });
          break;
        case 'webp':
          pipeline = pipeline.webp({ quality });
          break;
      }

      return await pipeline.toBuffer();
    } catch (error) {
      console.error('Image resize error:', error);
      throw new Error(`Failed to resize image: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Convert image to WebP format with quality optimization
   * Uses 85% quality for optimal size/quality balance
   */
  async convertToWebP(buffer: Buffer, quality: number = this.WEBP_QUALITY): Promise<Buffer> {
    try {
      return await sharp(buffer)
        .webp({
          quality,
          effort: 6, // Higher effort for better compression (0-6, default 4)
          lossless: false, // Use lossy compression for smaller file sizes
          nearLossless: false,
          smartSubsample: true, // Better quality at lower file sizes
        })
        .toBuffer();
    } catch (error) {
      console.error('WebP conversion error:', error);
      throw new Error(`Failed to convert to WebP: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Process an image and generate both JPEG and WebP versions for all sizes
   * This method creates optimized versions in both formats for modern browser support
   */
  async processImageWithWebP(
    buffer: Buffer,
    options: ProcessingOptions = {}
  ): Promise<ImageSizesWithWebP> {
    try {
      const {
        quality = this.DEFAULT_QUALITY,
        generateSizes = true,
      } = options;

      // Validate image first
      const validation = await this.validateImage(buffer);
      if (!validation.isValid) {
        throw new Error(validation.error || 'Invalid image');
      }

      // Generate JPEG versions
      const jpegSizes = await this.processImage(buffer, {
        quality,
        format: 'jpeg',
        generateSizes,
      });

      // Generate WebP versions with optimized quality
      const webpSizes = await this.processImage(buffer, {
        quality: this.WEBP_QUALITY,
        format: 'webp',
        generateSizes,
      });

      return {
        jpeg: jpegSizes,
        webp: webpSizes,
      };
    } catch (error) {
      console.error('Image processing with WebP error:', error);
      throw new Error(`Failed to process image with WebP: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate an image buffer
   */
  async validateImage(buffer: Buffer): Promise<ValidationResult> {
    try {
      // Check file size
      if (buffer.length > this.MAX_FILE_SIZE) {
        return {
          isValid: false,
          error: `File size exceeds maximum allowed size of ${this.MAX_FILE_SIZE / 1024 / 1024}MB`,
        };
      }

      // Get image metadata
      const metadata = await sharp(buffer).metadata();

      // Check format
      if (!metadata.format || !this.ALLOWED_FORMATS.includes(metadata.format)) {
        return {
          isValid: false,
          error: `Invalid image format. Allowed formats: ${this.ALLOWED_FORMATS.join(', ')}`,
        };
      }

      // Check dimensions
      if (!metadata.width || !metadata.height) {
        return {
          isValid: false,
          error: 'Unable to determine image dimensions',
        };
      }

      if (metadata.width < this.MIN_WIDTH || metadata.height < this.MIN_HEIGHT) {
        return {
          isValid: false,
          error: `Image dimensions too small. Minimum: ${this.MIN_WIDTH}x${this.MIN_HEIGHT}px`,
        };
      }

      return {
        isValid: true,
        width: metadata.width,
        height: metadata.height,
        format: metadata.format,
        size: buffer.length,
      };
    } catch (error) {
      return {
        isValid: false,
        error: `Invalid image file: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Validate image dimensions
   */
  async validateDimensions(
    buffer: Buffer,
    minWidth: number,
    minHeight: number,
    maxWidth?: number,
    maxHeight?: number
  ): Promise<ValidationResult> {
    try {
      const metadata = await sharp(buffer).metadata();

      if (!metadata.width || !metadata.height) {
        return {
          isValid: false,
          error: 'Unable to determine image dimensions',
        };
      }

      if (metadata.width < minWidth || metadata.height < minHeight) {
        return {
          isValid: false,
          error: `Image too small. Minimum: ${minWidth}x${minHeight}px`,
        };
      }

      if (maxWidth && maxHeight) {
        if (metadata.width > maxWidth || metadata.height > maxHeight) {
          return {
            isValid: false,
            error: `Image too large. Maximum: ${maxWidth}x${maxHeight}px`,
          };
        }
      }

      return {
        isValid: true,
        width: metadata.width,
        height: metadata.height,
        format: metadata.format,
      };
    } catch (error) {
      return {
        isValid: false,
        error: `Failed to validate dimensions: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Get image metadata
   */
  async getMetadata(buffer: Buffer): Promise<sharp.Metadata> {
    try {
      return await sharp(buffer).metadata();
    } catch (error) {
      throw new Error(`Failed to get image metadata: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Extract dominant colors from image
   */
  async extractColors(buffer: Buffer, count: number = 5): Promise<string[]> {
    try {
      const stats = await sharp(buffer)
        .resize(100, 100, { fit: 'cover' })
        .stats();

      // Extract dominant color from stats
      // This is a simplified version - you might want to use a color quantization library
      // for more accurate color extraction
      if (stats.dominant) {
        const { r, g, b } = stats.dominant;
        const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        return [hex];
      }

      return [];
    } catch (error) {
      console.error('Color extraction error:', error);
      return [];
    }
  }
}

// Export singleton instance
export default new ImageProcessingService();
